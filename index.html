<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>OSION – Jeans Live Scan</title>
  <meta name="description" content="Jeans Live Scan: Kamera-gestützter Größen-Scan (W/L) mit Wahrscheinlichkeiten und optionaler Vorschau. Foto bleibt im Browser." />

  <style>
    :root{
      --bg0:#070a14; --bg1:#0b1030; --bg2:#171a3a;
      --text:#eaf0ff; --muted: rgba(234,240,255,.72);
      --bad:#ff6b6b; --gold:#ffd36a; --good:#45d483;
      --a1:#b3003c; --a2:#6b2cff;
      --r:18px; --r2:26px;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1400px 900px at 22% 12%, rgba(107,44,255,.22), transparent 58%),
        radial-gradient(1100px 820px at 78% 10%, rgba(179,0,60,.22), transparent 58%),
        radial-gradient(900px 700px at 55% 95%, rgba(255,255,255,.06), transparent 62%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 45%, var(--bg2));
      overflow-x:hidden;
    }

    .wrap{ max-width: 1180px; margin:0 auto; padding: 18px 14px 44px; }

    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding: 12px 12px;
      border: 1px solid rgba(255,255,255,.14);
      border-radius: var(--r2);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.025));
      box-shadow: 0 22px 80px rgba(0,0,0,.55);
      backdrop-filter: blur(12px);
    }
    .brand{ display:flex; align-items:center; gap:12px; min-width: 240px; }
    .logo{
      width:48px; height:48px; border-radius: 16px;
      border:1px solid rgba(255,255,255,.18);
      background: linear-gradient(135deg, rgba(179,0,60,.25), rgba(107,44,255,.25));
      display:grid; place-items:center; overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
      flex:0 0 auto;
    }
    .logo img{ width:100%; height:100%; object-fit:cover; display:block; }
    .brand h1{ margin:0; font-size: 14px; letter-spacing:.25px; font-weight: 950; line-height:1.15; }
    .brand .sub{ margin-top:2px; font-size: 12px; color: var(--muted); line-height:1.2; }

    .badgeRow{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
    .pill{
      display:flex; align-items:center; gap:8px;
      padding: 10px 12px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      color: rgba(234,240,255,.78);
      font-size: 12px;
      white-space:nowrap;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: linear-gradient(135deg, var(--a1), var(--a2));
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
    }

    .grid{
      margin-top: 14px;
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      border: 1px solid rgba(255,255,255,.14);
      border-radius: var(--r2);
      background:
        radial-gradient(900px 260px at 10% 0%, rgba(255,255,255,.07), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: 0 28px 110px rgba(0,0,0,.55);
      backdrop-filter: blur(12px);
      overflow:hidden;
    }
    .cardHead{
      padding: 14px 14px 0;
      display:flex; align-items:flex-start; justify-content:space-between; gap: 12px;
    }
    .cardTitle{ margin:0; font-size: 16px; font-weight: 950; letter-spacing:.3px; }
    .cardHint{ margin: 6px 0 0; font-size: 13px; color: var(--muted); line-height:1.35; }
    .cardBody{ padding: 12px 14px 14px; }

    .actions{ display:flex; gap:10px; flex-wrap:wrap; margin-top: 8px; }
    .btn{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.045);
      color: var(--text);
      padding: 11px 12px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 950;
      letter-spacing:.2px;
      transition: transform .15s ease, border-color .15s ease, background .15s ease;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.25); }
    .btn.primary{
      border-color: rgba(255,255,255,.18);
      background: linear-gradient(135deg, rgba(179,0,60,.34), rgba(107,44,255,.34));
    }
    .btn.primary:hover{
      background: linear-gradient(135deg, rgba(179,0,60,.42), rgba(107,44,255,.42));
    }
    .btn.ghost{ background:transparent; box-shadow:none; }

    .stage{
      border: 1px solid rgba(255,255,255,.14);
      border-radius: var(--r2);
      background: rgba(0,0,0,.18);
      padding: 12px;
      overflow:hidden;
    }
    .canvasWrap{
      position:relative;
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      aspect-ratio: 3 / 4;
    }

    video, canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
    }

    #video{ transform: scaleX(-1); } /* selfie mirror for better UX */
    #view, #overlay, #tryon{
      pointer-events:none;
    }
    #view{ opacity:0; } /* we draw view only after capture */
    #tryon{ mix-blend-mode: screen; opacity: .92; }

    .status{
      margin-top:10px;
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      font-size: 12px;
      color: var(--muted);
    }
    .chip{
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      color: rgba(234,240,255,.78);
      font-size: 12px;
    }
    .chip.good{ border-color: rgba(69,212,131,.35); }
    .chip.warn{ border-color: rgba(255,211,106,.35); }
    .chip.bad{ border-color: rgba(255,107,107,.35); }

    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 12px;
    }
    @media (max-width: 560px){ .row{ grid-template-columns:1fr; } }

    label{ display:block; font-size: 12px; color: var(--muted); margin: 0 0 6px; }
    input, select{
      width:100%;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(10,12,28,.72), rgba(10,12,28,.46));
      color: var(--text);
      outline:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 10px 30px rgba(0,0,0,.35);
    }
    input::placeholder{ color: rgba(185,194,232,.55); }

    .result{
      margin-top: 12px;
      padding: 14px;
      border-radius: var(--r2);
      border: 1px solid rgba(255,255,255,.16);
      background:
        radial-gradient(820px 240px at 0% 0%, rgba(179,0,60,.14), transparent 55%),
        radial-gradient(820px 240px at 100% 0%, rgba(107,44,255,.14), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: 0 26px 90px rgba(0,0,0,.55);
      display:none;
    }
    .resultTop{ display:flex; align-items:flex-start; justify-content:space-between; gap: 12px; flex-wrap:wrap; }
    .sizeBig{ display:flex; gap:10px; align-items:baseline; flex-wrap:wrap; }
    .sizeBig .w{
      font-size: 22px;
      font-weight: 950;
      letter-spacing:.6px;
      display:inline-block;
      padding: 10px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .sizeBig .meta{ font-size: 13px; color: var(--muted); margin-top: 6px; }

    .confidence{ min-width: 240px; max-width: 340px; flex: 1; }
    .confLabel{
      font-size: 12px; color: var(--muted); margin-bottom: 6px;
      display:flex; justify-content:space-between; gap: 12px;
    }
    .bar{
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      overflow:hidden;
    }
    .bar > i{
      display:block; height:100%; width:0%;
      background: linear-gradient(90deg, var(--bad), var(--gold), var(--good));
      border-radius: 999px;
      transition: width .3s ease;
    }

    .bullets{
      margin: 10px 0 0;
      padding: 0 0 0 16px;
      color: var(--muted);
      line-height:1.45;
      font-size: 13px;
    }

    .probGrid{
      margin-top: 12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 560px){ .probGrid{ grid-template-columns:1fr; } }

    .prob{
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      background: rgba(255,255,255,.03);
      padding: 12px;
    }
    .probTop{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .probTop b{ font-size: 13px; letter-spacing:.2px; }
    .probTop span{ font-family: var(--mono); font-size: 12px; color: rgba(234,240,255,.72); }
    .probBar{
      margin-top: 10px; height: 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      overflow:hidden;
    }
    .probBar i{
      display:block; height:100%; width:0%;
      background: linear-gradient(90deg, rgba(179,0,60,.75), rgba(107,44,255,.75));
      border-radius: 999px;
      transition: width .3s ease;
    }

    .tile{
      border: 1px solid rgba(255,255,255,.12);
      border-radius: var(--r2);
      background: rgba(255,255,255,.028);
      padding: 12px;
      margin-top:12px;
    }
    .tile h3{ margin:0; font-size: 13px; letter-spacing:.25px; font-weight: 950; }
    .tile p{ margin: 6px 0 0; font-size: 12px; color: var(--muted); line-height:1.45; }

    .sliders{
      display:grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px;
    }
    @media (max-width: 560px){ .sliders{ grid-template-columns:1fr; } }
    .rangeWrap{
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      background: rgba(255,255,255,.03);
      padding: 12px;
    }
    .rangeWrap .top{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      font-size: 12px; color: var(--muted); margin-bottom: 8px;
    }
    input[type="range"]{ width:100%; }

    .foot{
      margin-top: 12px;
      font-size: 12px;
      color: rgba(255,255,255,.55);
      text-align:center;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true">
          <img src="MGU-0015 Logo OSION Solution XR.png" alt="OSION Logo"
               onerror="this.style.display='none'; this.parentElement.textContent='OSION'; this.parentElement.style.fontWeight='950'; this.parentElement.style.fontSize='14px';" />
        </div>
        <div>
          <h1>OSION Fit Check – Jeans</h1>
          <div class="sub">Live-Kamera Scan · Größenwahrscheinlichkeit (W/L) · optional Vorschau</div>
        </div>
      </div>

      <div class="badgeRow">
        <div class="pill"><span class="dot"></span> Standard: Live-Kamera</div>
        <div class="pill">Foto bleibt im Browser</div>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT: Live Camera -->
      <section class="card" aria-label="Live-Kamera">
        <div class="cardHead">
          <div>
            <h2 class="cardTitle">Live-Kamera</h2>
            <p class="cardHint">Ganzkörper im Bild, gerade stehen, gute Beleuchtung. Wenn die Ampel grün ist, Scan auslösen.</p>
          </div>
          <div class="actions">
            <button class="btn" id="startCam">Kamera starten</button>
            <button class="btn" id="flipCam" disabled>Kamera wechseln</button>
            <button class="btn primary" id="capture" disabled>Scan auslösen</button>
          </div>
        </div>

        <div class="cardBody">
          <div class="stage">
            <div class="canvasWrap">
              <video id="video" playsinline autoplay muted></video>
              <canvas id="view"></canvas>
              <canvas id="tryon"></canvas>
              <canvas id="overlay"></canvas>
            </div>

            <div class="status">
              <span class="chip" id="modelState">KI-Modul: wird geladen …</span>
              <span class="chip" id="camState">Kamera: aus</span>
              <span class="chip warn" id="liveState">Ampel: warten</span>
            </div>

            <div class="tile">
              <h3>Marker (optional)</h3>
              <p>Für stabilere Skalierung: A4-Blatt im Bild halten. Dann Marker aktivieren und 2 Punkte auf die Blattbreite setzen.</p>
              <div class="row" style="margin-top:10px;">
                <div class="field">
                  <label for="refMode">Marker</label>
                  <select id="refMode">
                    <option value="none" selected>kein Marker</option>
                    <option value="a4_21">A4 Breite 21,0 cm</option>
                    <option value="a4_297">A4 Breite 29,7 cm</option>
                  </select>
                </div>
                <div class="field">
                  <label>Aktion</label>
                  <button class="btn" id="clearRef">Marker-Punkte löschen</button>
                </div>
              </div>

              <div class="status" style="margin-top:10px;">
                <span class="chip" id="refState">Marker: aus</span>
                <span class="chip" id="hintState">Hinweis: —</span>
              </div>
            </div>

            <div class="foot">OSION · Live Scan</div>
          </div>
        </div>
      </section>

      <!-- RIGHT: Inputs + Results + Try-on -->
      <section class="card" aria-label="Scan und Vorschau">
        <div class="cardHead">
          <div>
            <h2 class="cardTitle">Größen-Scan</h2>
            <p class="cardHint">Maße sind optional. Mit Taille-Umfang und Innenbeinlänge wird der Scan präziser.</p>
          </div>
        </div>

        <div class="cardBody">
          <div class="row">
            <div class="field">
              <label for="height">Körpergröße (optional)</label>
              <input id="height" type="number" inputmode="numeric" min="120" max="220" placeholder="z. B. 182" />
            </div>
            <div class="field">
              <label for="weight">Gewicht (optional)</label>
              <input id="weight" type="number" inputmode="numeric" min="35" max="200" placeholder="z. B. 84" />
            </div>
          </div>

          <div class="row">
            <div class="field">
              <label for="waist">Taille-Umfang (optional)</label>
              <input id="waist" type="number" inputmode="numeric" min="55" max="140" placeholder="z. B. 88" />
            </div>
            <div class="field">
              <label for="inseam">Innenbeinlänge (optional)</label>
              <input id="inseam" type="number" inputmode="numeric" min="55" max="105" placeholder="z. B. 82" />
            </div>
          </div>

          <div class="row">
            <div class="field">
              <label for="fit">Sitz-Wunsch</label>
              <select id="fit">
                <option value="regular" selected>Normal</option>
                <option value="slim">Enger</option>
                <option value="loose">Lockerer</option>
              </select>
            </div>
            <div class="field">
              <label for="stretch">Stretch-Anteil</label>
              <select id="stretch">
                <option value="none">Kein Stretch</option>
                <option value="some" selected>Etwas Stretch</option>
                <option value="high">Viel Stretch</option>
              </select>
            </div>
          </div>

          <div class="row">
            <div class="field">
              <label for="brand">Passform-Tendenz (optional)</label>
              <select id="brand">
                <option value="tts" selected>Fällt normal aus</option>
                <option value="small">Fällt eher klein aus</option>
                <option value="large">Fällt eher groß aus</option>
              </select>
            </div>
            <div class="field">
              <label for="targetWL">Geplante Größe (optional)</label>
              <input id="targetWL" type="text" placeholder="z. B. W32 / L32" />
            </div>
          </div>

          <div class="actions">
            <button class="btn primary" id="runScan" disabled>Scan berechnen</button>
            <button class="btn" id="reset">Zurücksetzen</button>
          </div>

          <div class="result" id="result">
            <div class="resultTop">
              <div>
                <div class="sizeBig">
                  <div class="w" id="wlOut">W— / L—</div>
                  <div class="meta" id="metaOut">Wahrscheinlichste Größe aus Live-Scan + Angaben.</div>
                </div>
              </div>
              <div class="confidence">
                <div class="confLabel">
                  <span>Scan-Sicherheit</span>
                  <b id="confText">—</b>
                </div>
                <div class="bar"><i id="confBar"></i></div>
              </div>
            </div>

            <ul class="bullets" id="bullets"></ul>
            <div class="probGrid" id="probGrid"></div>

            <div class="tile">
              <h3>Vorschau (optional)</h3>
              <p>Jeans PNG (freigestellt) laden. Vorschau legt die Jeans als Overlay über das Livebild.</p>
              <div class="actions" style="margin-top:10px;">
                <label class="btn ghost" for="jeansFile">Jeans PNG wählen</label>
                <input id="jeansFile" type="file" accept="image/png,image/*" hidden />
                <button class="btn" id="applyOverlay" disabled>Vorschau aktivieren</button>
                <button class="btn" id="clearOverlay" disabled>Vorschau entfernen</button>
              </div>

              <div class="sliders">
                <div class="rangeWrap">
                  <div class="top"><span>Skalierung</span><b id="scaleVal">100%</b></div>
                  <input id="scale" type="range" min="70" max="140" value="100" />
                </div>
                <div class="rangeWrap">
                  <div class="top"><span>Transparenz</span><b id="alphaVal">92%</b></div>
                  <input id="alpha" type="range" min="40" max="100" value="92" />
                </div>
              </div>

              <div class="sliders">
                <div class="rangeWrap">
                  <div class="top"><span>Vertikal</span><b id="yVal">0</b></div>
                  <input id="yOff" type="range" min="-220" max="220" value="0" />
                </div>
                <div class="rangeWrap">
                  <div class="top"><span>Horizontal</span><b id="xVal">0</b></div>
                  <input id="xOff" type="range" min="-220" max="220" value="0" />
                </div>
              </div>
            </div>
          </div>

          <div class="foot">OSION · Jeans Live Scan</div>
        </div>
      </section>
    </div>
  </div>

  <script>
    const $ = (id)=>document.getElementById(id);

    const el = {
      video: $("video"),
      view: $("view"),
      overlay: $("overlay"),
      tryon: $("tryon"),

      startCam: $("startCam"),
      flipCam: $("flipCam"),
      capture: $("capture"),

      modelState: $("modelState"),
      camState: $("camState"),
      liveState: $("liveState"),
      hintState: $("hintState"),

      refMode: $("refMode"),
      clearRef: $("clearRef"),
      refState: $("refState"),

      height: $("height"),
      weight: $("weight"),
      waist: $("waist"),
      inseam: $("inseam"),
      fit: $("fit"),
      stretch: $("stretch"),
      brand: $("brand"),
      targetWL: $("targetWL"),

      runScan: $("runScan"),
      reset: $("reset"),

      result: $("result"),
      wlOut: $("wlOut"),
      metaOut: $("metaOut"),
      bullets: $("bullets"),
      probGrid: $("probGrid"),
      confText: $("confText"),
      confBar: $("confBar"),

      jeansFile: $("jeansFile"),
      applyOverlay: $("applyOverlay"),
      clearOverlay: $("clearOverlay"),
      scale: $("scale"),
      alpha: $("alpha"),
      yOff: $("yOff"),
      xOff: $("xOff"),
      scaleVal: $("scaleVal"),
      alphaVal: $("alphaVal"),
      yVal: $("yVal"),
      xVal: $("xVal"),
    };

    const ctxV = el.view.getContext("2d");
    const ctxO = el.overlay.getContext("2d");
    const ctxT = el.tryon.getContext("2d");

    let poseLandmarker = null;
    let stream = null;
    let facingMode = "user"; // start selfie; flip to environment
    let running = false;

    // marker clicks (on overlay canvas)
    let refClicks = [];
    let pixelsPerCm = null;

    // pose points last stable
    let lastPose = null;
    let lastPoseOk = false;

    // captured bitmap for scan compute
    let capturedBitmap = null;

    // jeans overlay
    let jeansBitmap = null;

    const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
    const dist=(a,b)=>Math.hypot(a.x-b.x, a.y-b.y);

    function setLiveChip(state, text){
      el.liveState.textContent = "Ampel: " + text;
      el.liveState.classList.remove("good","warn","bad");
      el.liveState.classList.add(state);
    }

    function setHint(text){
      el.hintState.textContent = "Hinweis: " + (text || "—");
    }

    function resizeLayers(w,h){
      el.view.width = w; el.view.height = h;
      el.overlay.width = w; el.overlay.height = h;
      el.tryon.width = w; el.tryon.height = h;
    }

    function clearOverlays(){
      ctxO.clearRect(0,0,el.overlay.width, el.overlay.height);
      ctxT.clearRect(0,0,el.tryon.width, el.tryon.height);
    }

    function pickRefCm(){
      if(el.refMode.value === "a4_21") return 21.0;
      if(el.refMode.value === "a4_297") return 29.7;
      return null;
    }

    function computePixelsPerCm(){
      const refCm = pickRefCm();
      if(!refCm) return null;
      if(refClicks.length !== 2) return null;
      const px = dist(refClicks[0], refClicks[1]);
      if(px < 10) return null;
      return px / refCm;
    }

    function updateRefState(){
      const label = el.refMode.value === "none" ? "aus" :
        (el.refMode.value === "a4_21" ? "A4 21,0 cm" : "A4 29,7 cm");
      el.refState.textContent = "Marker: " + label + (pixelsPerCm ? " · aktiv" : "");
    }

    function canvasToImageCoords(evt){
      const rect = el.overlay.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (el.overlay.width / rect.width);
      const y = (evt.clientY - rect.top) * (el.overlay.height / rect.height);
      return {x,y};
    }

    el.overlay.addEventListener("click", (evt)=>{
      if(el.refMode.value === "none") return;
      if(!running) return;

      const p = canvasToImageCoords(evt);
      if(refClicks.length >= 2) refClicks = [];
      refClicks.push(p);
      pixelsPerCm = computePixelsPerCm();
      drawOverlay(lastPose);
      updateRefState();
    });

    el.clearRef.addEventListener("click", ()=>{
      refClicks = [];
      pixelsPerCm = null;
      drawOverlay(lastPose);
      updateRefState();
    });

    el.refMode.addEventListener("change", ()=>{
      refClicks = [];
      pixelsPerCm = null;
      drawOverlay(lastPose);
      updateRefState();
    });

    function drawMarkerClicks(){
      if(refClicks.length === 0) return;
      ctxO.save();
      ctxO.lineWidth = 4;
      ctxO.strokeStyle = "rgba(255,255,255,.85)";
      ctxO.fillStyle = "rgba(255,255,255,.85)";
      for(const p of refClicks){
        ctxO.beginPath();
        ctxO.arc(p.x, p.y, 7, 0, Math.PI*2);
        ctxO.fill();
      }
      if(refClicks.length === 2){
        ctxO.beginPath();
        ctxO.moveTo(refClicks[0].x, refClicks[0].y);
        ctxO.lineTo(refClicks[1].x, refClicks[1].y);
        ctxO.stroke();
      }
      ctxO.restore();
    }

    function drawOverlay(pts){
      clearOverlays();
      if(!pts){ drawMarkerClicks(); return; }

      ctxO.save();
      ctxO.lineWidth = 4;
      ctxO.strokeStyle = "rgba(255,255,255,.72)";
      ctxO.fillStyle = "rgba(255,255,255,.92)";

      const drawPt=(p,r=6)=>{ ctxO.beginPath(); ctxO.arc(p.x,p.y,r,0,Math.PI*2); ctxO.fill(); };
      const drawLine=(a,b)=>{ ctxO.beginPath(); ctxO.moveTo(a.x,a.y); ctxO.lineTo(b.x,b.y); ctxO.stroke(); };

      // frame guide box (safe area)
      ctxO.globalAlpha = 0.25;
      ctxO.strokeStyle = "rgba(255,255,255,.8)";
      const pad = el.overlay.width * 0.08;
      ctxO.strokeRect(pad, pad*0.9, el.overlay.width - pad*2, el.overlay.height - pad*1.5);
      ctxO.globalAlpha = 1.0;
      ctxO.strokeStyle = "rgba(255,255,255,.72)";

      // hips + legs
      drawLine(pts.lh, pts.rh);
      drawLine(pts.lh, pts.lk); drawLine(pts.lk, pts.la);
      drawLine(pts.rh, pts.rk); drawLine(pts.rk, pts.ra);

      drawPt(pts.lh,7); drawPt(pts.rh,7);
      drawPt(pts.lk,6); drawPt(pts.rk,6);
      drawPt(pts.la,6); drawPt(pts.ra,6);

      ctxO.restore();
      drawMarkerClicks();
    }

    function poseQuality(pts){
      if(!pts) return { ok:false, ready:false, hint:"Körper nicht erkannt." };

      // ordering: hip above knee above ankle
      const legLeftOk = (pts.lk.y > pts.lh.y && pts.la.y > pts.lk.y);
      const legRightOk = (pts.rk.y > pts.rh.y && pts.ra.y > pts.rk.y);

      // hips roughly level
      const hipTilt = Math.abs(pts.lh.y - pts.rh.y);

      // full body in frame: ankles not too close to bottom edge, head not tracked here, so use hip position as proxy
      const marginBottomOk = (Math.max(pts.la.y, pts.ra.y) < el.overlay.height * 0.95);
      const marginTopOk = (Math.min(pts.lh.y, pts.rh.y) > el.overlay.height * 0.18);

      let hint = "";
      if(!marginBottomOk) hint = "Ein Schritt zurück, Füße vollständig ins Bild.";
      else if(!marginTopOk) hint = "Kamera tiefer oder Abstand erhöhen.";
      else if(!legLeftOk || !legRightOk) hint = "Beine gerade stellen.";
      else if(hipTilt > el.overlay.height * 0.06) hint = "Kamera gerade halten.";
      else hint = "Bereit zum Scan.";

      const ready = marginBottomOk && marginTopOk && legLeftOk && legRightOk && hipTilt <= el.overlay.height * 0.06;
      return { ok:true, ready, hint };
    }

    // ---------- Size logic ----------
    function cmToIn(cm){ return cm/2.54; }
    function mapL(inches){
      const opts=[28,30,32,34,36];
      let best=opts[0], bestD=1e9;
      for(const o of opts){
        const d=Math.abs(o-inches);
        if(d<bestD){ bestD=d; best=o; }
      }
      return best;
    }
    function mapW(inches){ return clamp(Math.round(inches), 26, 44); }

    function parseTargetWL(str){
      if(!str) return null;
      const m = str.toUpperCase().replace(/\s/g,"").match(/W(\d+)[\/-]?L(\d+)/);
      if(!m) return null;
      return { W:Number(m[1]), L:Number(m[2]) };
    }

    function estimateWaistCmFromHeightWeight(hCm, wKg){
      if(!hCm || !wKg) return null;
      const hM = hCm/100;
      const bmi = wKg / (hM*hM);
      let waist = hCm * 0.42 + (bmi - 22) * 1.8;
      return Math.round(clamp(waist, 68, 125));
    }
    function estimateInseamCmFromHeight(hCm){
      if(!hCm) return null;
      return Math.round(hCm * 0.45);
    }

    function adjustW(W){
      const fit = el.fit.value;
      const stretch = el.stretch.value;
      const brand = el.brand.value;
      if (fit === "slim") W -= 1;
      if (fit === "loose") W += 1;
      if (stretch === "high") W -= 1;
      if (brand === "small") W += 1;
      if (brand === "large") W -= 1;
      return clamp(W, 26, 44);
    }

    function confidenceScore({ ready, hasMarker, hasWaist, hasInseam, hasHeightWeight }){
      let s = 25;
      if(ready) s += 38;
      if(hasMarker) s += 12;
      if(hasWaist) s += 15;
      if(hasInseam) s += 10;
      if(hasHeightWeight) s += 8;
      return clamp(s, 20, 95);
    }
    function confLabel(score){
      if(score >= 78) return "hoch";
      if(score >= 55) return "mittel";
      return "niedrig";
    }

    function buildCandidates(mainWL){
      const base = [
        {W: mainWL.W,   L: mainWL.L},
        {W: mainWL.W+1, L: mainWL.L},
        {W: mainWL.W-1, L: mainWL.L},
        {W: mainWL.W,   L: mainWL.L+2},
        {W: mainWL.W,   L: mainWL.L-2},
      ].map(x=>({ ...x, W: clamp(x.W,26,44), L: clamp(x.L,28,36) }));

      const uniq = [];
      const seen = new Set();
      for(const c of base){
        const k = `W${c.W}L${c.L}`;
        if(seen.has(k)) continue;
        seen.add(k);
        uniq.push(c);
      }
      return uniq.slice(0,4);
    }
    function scoreCandidate(c, mainWL, conf){
      const d = Math.abs(c.W-mainWL.W)*1.2 + Math.abs(c.L-mainWL.L)*0.7;
      const base = 1 / (1 + d);
      return base * (0.6 + conf/200);
    }
    function normalizeProbs(items){
      const sum = items.reduce((a,x)=>a+x.s,0) || 1;
      return items.map(x=>({ ...x, p: x.s/sum }));
    }

    function buildMainWLFromInputsAndPose(posePts){
      const heightCm = Number(el.height.value||0) || null;
      const weightKg = Number(el.weight.value||0) || null;
      const waistCmIn = Number(el.waist.value||0) || null;
      const inseamCmIn = Number(el.inseam.value||0) || null;

      let waistCm = waistCmIn;
      let inseamCm = inseamCmIn;

      if(!waistCm) waistCm = estimateWaistCmFromHeightWeight(heightCm, weightKg);
      if(!inseamCm) inseamCm = estimateInseamCmFromHeight(heightCm);

      // marker refinement for inseam proxy (conservative)
      if(pixelsPerCm && posePts && posePts.la && posePts.lh && !inseamCmIn){
        const inseamPx = Math.abs(posePts.la.y - posePts.lh.y);
        const approxCm = Math.round(inseamPx / pixelsPerCm);
        inseamCm = clamp(Math.round((inseamCm + approxCm) / 2), 60, 100);
      }

      let W = waistCm ? mapW(cmToIn(waistCm)) : 32;
      let L = inseamCm ? mapL(Math.round(cmToIn(inseamCm))) : 32;

      W = adjustW(W);
      L = clamp(L, 28, 36);

      return {
        W, L,
        used: {
          waist: !!waistCmIn,
          inseam: !!inseamCmIn,
          heightWeight: !!(heightCm && weightKg),
          marker: !!pixelsPerCm
        }
      };
    }

    function renderResult(main, pq){
      const target = parseTargetWL(el.targetWL.value);
      const conf = confidenceScore({
        ready: pq.ready,
        hasMarker: !!pixelsPerCm,
        hasWaist: main.used.waist,
        hasInseam: main.used.inseam,
        hasHeightWeight: main.used.heightWeight
      });
      const label = confLabel(conf);

      el.wlOut.textContent = `W${main.W} / L${main.L}`;
      el.metaOut.textContent = "Wahrscheinlichste Größe aus Live-Scan + Angaben.";

      el.confText.textContent = label;
      el.confBar.style.width = `${conf}%`;

      const bullets = [];
      bullets.push(`Empfehlung: W${main.W} / L${main.L}.`);
      bullets.push(pq.ready ? "Live-Scan: Pose wirkt stabil." : "Live-Scan: Pose ist nicht optimal, Ergebnis ist vorsichtiger.");

      if(main.used.waist) bullets.push("Taille-Umfang wurde berücksichtigt.");
      else bullets.push("Taille-Umfang ist optional. Mit Messwert wird das Ergebnis präziser.");

      if(main.used.inseam) bullets.push("Innenbeinlänge wurde berücksichtigt.");
      else bullets.push("Innenbeinlänge ist optional. Mit Messwert wird das Ergebnis präziser.");

      if(pixelsPerCm) bullets.push("Marker ist aktiv: Skalierung ist stabiler.");
      else bullets.push("Ohne Marker ist Skalierung stärker von Perspektive abhängig.");

      if(target){
        const dW = main.W - target.W;
        const dL = main.L - target.L;
        if(dW === 0 && dL === 0) bullets.push("Geplante Größe passt zur Empfehlung.");
        else{
          if(dW !== 0) bullets.push(dW>0 ? `Im Vergleich zur geplanten Größe ist die Weite eher größer (+${dW}).` : `Im Vergleich zur geplanten Größe ist die Weite eher kleiner (${dW}).`);
          if(dL !== 0) bullets.push(dL>0 ? `Im Vergleich zur geplanten Größe ist die Länge eher länger (+${dL}).` : `Im Vergleich zur geplanten Größe ist die Länge eher kürzer (${dL}).`);
        }
      }

      el.bullets.innerHTML = bullets.map(x=>`<li>${x}</li>`).join("");

      const cands = buildCandidates(main);
      const scored = cands.map(c=>({ ...c, s: scoreCandidate(c, main, conf) }));
      const probs = normalizeProbs(scored).sort((a,b)=>b.p-a.p);

      el.probGrid.innerHTML = probs.map((c,i)=>{
        const pct = Math.round(c.p*100);
        const tag = (i===0) ? "Haupttreffer" : "Alternative";
        return `
          <div class="prob">
            <div class="probTop">
              <b>W${c.W} / L${c.L}</b>
              <span>${tag} · ${pct}%</span>
            </div>
            <div class="probBar"><i style="width:${pct}%;"></i></div>
          </div>
        `;
      }).join("");

      el.result.style.display = "block";

      // enable overlay controls if jeans loaded
      el.applyOverlay.disabled = !(jeansBitmap && lastPose);
      el.clearOverlay.disabled = !(lastPose);
    }

    // ---------- MediaPipe loader ----------
    async function loadPose(){
      try{
        el.modelState.textContent = "KI-Modul: wird geladen …";
        const vision = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs");
        const { FilesetResolver, PoseLandmarker } = vision;

        const fileset = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
        );

        poseLandmarker = await PoseLandmarker.createFromOptions(fileset, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numPoses: 1
        });

        el.modelState.textContent = "KI-Modul: bereit";
      }catch(e){
        console.error(e);
        el.modelState.textContent = "KI-Modul: nicht verfügbar (CDN/Netzwerk)";
        poseLandmarker = null;
      }
    }

    // ---------- Camera ----------
    async function startCamera(){
      if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
        el.camState.textContent = "Kamera: nicht verfügbar";
        setLiveChip("bad","nicht verfügbar");
        return;
      }

      if(stream){
        stream.getTracks().forEach(t=>t.stop());
        stream = null;
      }

      const constraints = {
        audio: false,
        video: {
          facingMode: { ideal: facingMode },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      };

      try{
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        el.video.srcObject = stream;

        await new Promise((res)=>el.video.onloadedmetadata = ()=>res());

        // fit canvases to actual video size
        resizeLayers(el.video.videoWidth || 720, el.video.videoHeight || 960);
        running = true;

        el.camState.textContent = "Kamera: an";
        el.flipCam.disabled = false;
        el.capture.disabled = !poseLandmarker;

        setLiveChip("warn","warten");
        setHint("Körper wird gesucht …");

        requestAnimationFrame(loop);
      }catch(e){
        console.error(e);
        el.camState.textContent = "Kamera: Zugriff verweigert";
        setLiveChip("bad","kein Zugriff");
        setHint("Kamera-Freigabe erforderlich.");
      }
    }

    el.startCam.addEventListener("click", startCamera);

    el.flipCam.addEventListener("click", async ()=>{
      facingMode = (facingMode === "user") ? "environment" : "user";
      await startCamera();
    });

    // ---------- Live Pose Loop ----------
    function toPts(lms){
      const W = el.overlay.width, H = el.overlay.height;
      const p = (i)=>({ x: lms[i].x*W, y: lms[i].y*H, v: lms[i].visibility ?? 1 });
      return { lh:p(23), rh:p(24), lk:p(25), rk:p(26), la:p(27), ra:p(28) };
    }

    let lastTs = 0;

    async function loop(ts){
      if(!running) return;

      // throttle to ~12-15 fps for mobile stability
      if(ts - lastTs < 70){
        requestAnimationFrame(loop);
        return;
      }
      lastTs = ts;

      if(!poseLandmarker){
        setLiveChip("bad","KI fehlt");
        setHint("KI-Modul ist nicht verfügbar.");
        requestAnimationFrame(loop);
        return;
      }

      const res = poseLandmarker.detectForVideo(el.video, ts);

      if(res && res.landmarks && res.landmarks.length){
        lastPose = toPts(res.landmarks[0]);

        // because video is mirrored, overlay should mirror too:
        // we mirror drawing by flipping context horizontally
        ctxO.save();
        ctxO.setTransform(-1, 0, 0, 1, el.overlay.width, 0);
        clearOverlays();
        drawOverlay(lastPose);
        ctxO.restore();

        const pq = poseQuality(lastPose);
        lastPoseOk = pq.ready;

        setHint(pq.hint);
        if(pq.ready){
          setLiveChip("good","bereit");
          el.capture.disabled = false;
        }else{
          setLiveChip("warn","anpassen");
          el.capture.disabled = false; // still allow capture, result will reflect lower confidence
        }
      }else{
        lastPose = null;
        lastPoseOk = false;

        clearOverlays();
        drawMarkerClicks();

        setLiveChip("bad","kein Körper");
        setHint("Ganzkörper ins Bild.");
        el.capture.disabled = true;
      }

      updateRefState();
      requestAnimationFrame(loop);
    }

    // ---------- Capture frame for scan ----------
    el.capture.addEventListener("click", async ()=>{
      if(!el.video.videoWidth || !el.video.videoHeight) return;

      // freeze current frame into view canvas (mirrored)
      el.view.style.opacity = "1";
      ctxV.save();
      ctxV.setTransform(-1, 0, 0, 1, el.view.width, 0);
      ctxV.drawImage(el.video, 0, 0, el.view.width, el.view.height);
      ctxV.restore();

      // create bitmap from view canvas
      capturedBitmap = await createImageBitmap(el.view);

      // enable scan
      el.runScan.disabled = false;

      // show result container after scan
      el.result.style.display = "none";
    });

    // ---------- Compute Scan ----------
    el.runScan.addEventListener("click", ()=>{
      if(!capturedBitmap && !lastPose){
        return;
      }

      // build from lastPose (live) + inputs + marker
      const pq = lastPose ? poseQuality(lastPose) : { ok:false, ready:false, hint:"Körper nicht erkannt." };
      const main = buildMainWLFromInputsAndPose(lastPose);

      renderResult(main, pq);

      // enable overlay buttons
      el.applyOverlay.disabled = !(jeansBitmap && lastPose);
      el.clearOverlay.disabled = !(lastPose);
    });

    el.reset.addEventListener("click", ()=>{
      el.height.value=""; el.weight.value="";
      el.waist.value=""; el.inseam.value="";
      el.fit.value="regular"; el.stretch.value="some"; el.brand.value="tts";
      el.targetWL.value="";
      el.result.style.display="none";
      el.confBar.style.width="0%";
      refClicks=[]; pixelsPerCm=null;
      updateRefState();
      setHint("—");
    });

    // ---------- Try-on overlay ----------
    function updateSliderLabels(){
      el.scaleVal.textContent = `${el.scale.value}%`;
      el.alphaVal.textContent = `${el.alpha.value}%`;
      el.yVal.textContent = `${el.yOff.value}`;
      el.xVal.textContent = `${el.xOff.value}`;
      el.tryon.style.opacity = (Number(el.alpha.value)/100).toFixed(2);
    }
    ["scale","alpha","yOff","xOff"].forEach(id=>{
      el[id].addEventListener("input", ()=>{
        updateSliderLabels();
        if(lastPose && jeansBitmap) drawTryonOverlay();
      });
    });
    updateSliderLabels();

    el.jeansFile.addEventListener("change", async ()=>{
      const f = el.jeansFile.files && el.jeansFile.files[0];
      if(!f) return;
      jeansBitmap = await createImageBitmap(f);
      el.applyOverlay.disabled = !(jeansBitmap && lastPose);
      el.clearOverlay.disabled = !(lastPose);
    });

    function drawTryonOverlay(){
      if(!lastPose || !jeansBitmap) return;

      // draw on tryon layer mirrored (because video is mirrored)
      ctxT.save();
      ctxT.setTransform(-1, 0, 0, 1, el.tryon.width, 0);
      ctxT.clearRect(0,0,el.tryon.width, el.tryon.height);

      const hipMid = { x:(lastPose.lh.x+lastPose.rh.x)/2, y:(lastPose.lh.y+lastPose.rh.y)/2 };
      const ankleMid = { x:(lastPose.la.x+lastPose.ra.x)/2, y:(lastPose.la.y+lastPose.ra.y)/2 };
      const hipWidth = dist(lastPose.lh, lastPose.rh);
      const legLen = Math.abs(ankleMid.y - hipMid.y);

      const s = Number(el.scale.value)/100;
      const targetW = hipWidth * 1.35 * s;
      const targetH = legLen * 1.15 * s;

      const angle = Math.atan2((lastPose.rh.y-lastPose.lh.y), (lastPose.rh.x-lastPose.lh.x));

      const xOff = Number(el.xOff.value);
      const yOff = Number(el.yOff.value);

      const cx = hipMid.x + xOff;
      const cy = hipMid.y + (targetH*0.08) + yOff;

      ctxT.translate(cx, cy);
      ctxT.rotate(angle);

      const bw = jeansBitmap.width, bh = jeansBitmap.height;
      const scale = Math.min(targetW/bw, targetH/bh);
      const dw = bw * scale;
      const dh = bh * scale;

      ctxT.globalAlpha = Number(el.alpha.value)/100;
      ctxT.drawImage(jeansBitmap, -dw/2, -dh*0.10, dw, dh);

      ctxT.restore();
    }

    el.applyOverlay.addEventListener("click", ()=>{
      drawTryonOverlay();
    });

    el.clearOverlay.addEventListener("click", ()=>{
      ctxT.clearRect(0,0,el.tryon.width, el.tryon.height);
    });

    // ---------- Boot ----------
    (async function(){
      await loadPose();
      el.capture.disabled = true;
      el.runScan.disabled = true;
      updateRefState();

      // Live-Kamera ist Standard: sofort starten, wenn möglich.
      // Hinweis: iOS verlangt oft einen User-Click; falls blockiert, Button bleibt nutzbar.
      try{
        await startCamera();
      }catch{
        // ignore
      }
    })();
  </script>
</body>
</html>
